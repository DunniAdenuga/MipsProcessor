$date
	Fri Sep  8 12:07:49 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$var wire 5 ! writeReg [4:0] $end
$var wire 11 " val [10:0] $end
$var wire 32 # v0 [31:0] $end
$var wire 32 $ signExtendData [31:0] $end
$var wire 32 % readData2 [31:0] $end
$var wire 32 & readData1 [31:0] $end
$var wire 32 ' next_addr [31:0] $end
$var wire 32 ( muxAluResult [31:0] $end
$var wire 32 ) jump_addr [31:0] $end
$var wire 32 * instruction [31:0] $end
$var wire 32 + current_addr [31:0] $end
$var wire 32 , aluResult [31:0] $end
$var wire 32 - add_addr [31:0] $end
$var wire 32 . a0 [31:0] $end
$var reg 1 / clock $end
$scope module add $end
$var wire 32 0 addr [31:0] $end
$var reg 32 1 out [31:0] $end
$upscope $end
$scope module al $end
$var wire 3 2 aluOp [2:0] $end
$var wire 32 3 readData2 [31:0] $end
$var wire 32 4 readData [31:0] $end
$var reg 32 5 aluResult [31:0] $end
$upscope $end
$scope module con $end
$var wire 32 6 instruction [31:0] $end
$var reg 11 7 val [10:0] $end
$upscope $end
$scope module m $end
$var wire 32 8 addrFromAdder [31:0] $end
$var wire 1 9 val $end
$var wire 32 : jumpAddr [31:0] $end
$var reg 32 ; next_addr [31:0] $end
$upscope $end
$scope module mem $end
$var wire 32 < addr [31:0] $end
$var reg 32 = instruction [31:0] $end
$var reg 32 > word_addr [31:0] $end
$upscope $end
$scope module muxForA $end
$var wire 1 ? aluSrc $end
$var wire 32 @ signExtendReadData [31:0] $end
$var wire 32 A readData2 [31:0] $end
$var reg 32 B muxResult [31:0] $end
$upscope $end
$scope module muxForR $end
$var wire 1 C RegDst $end
$var wire 32 D instruction [31:0] $end
$var reg 5 E writeReg [4:0] $end
$upscope $end
$scope module pc $end
$var wire 1 / clock $end
$var wire 32 F next_addr [31:0] $end
$var reg 32 G addr [31:0] $end
$upscope $end
$scope module regis $end
$var wire 5 H rd1 [4:0] $end
$var wire 5 I rd2 [4:0] $end
$var wire 32 J rr [31:0] $end
$var wire 1 K write $end
$var wire 5 L writeRegister [4:0] $end
$var reg 32 M a0 [31:0] $end
$var reg 32 N data1 [31:0] $end
$var reg 32 O data2 [31:0] $end
$var reg 32 P v0 [31:0] $end
$upscope $end
$scope module sE $end
$var wire 16 Q instruc [15:0] $end
$var reg 32 R signExtendReadData [31:0] $end
$upscope $end
$scope module shi $end
$var wire 32 S addr [31:0] $end
$var wire 32 T instruction [31:0] $end
$var reg 32 U jumpAddr [31:0] $end
$var reg 32 V next_addr [31:0] $end
$upscope $end
$scope module sys $end
$var wire 32 W a0 [31:0] $end
$var wire 32 X instruction [31:0] $end
$var wire 32 Y v0 [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx Y
b100100000010000000000000000001 X
bx W
b10000000000000000100100 V
b1000000000000000000100 U
b100100000010000000000000000001 T
b10000000000000000100000 S
b1 R
b1 Q
bx P
bx O
bx N
bx M
b1000 L
0K
bx J
b1000 I
b0 H
b10000000000000000100000 G
b10000000000000000100100 F
b1000 E
b100100000010000000000000000001 D
0C
bx B
bx A
b1 @
0?
b100000000000000001000 >
b100100000010000000000000000001 =
b10000000000000000100000 <
b10000000000000000100100 ;
b1000000000000000000100 :
09
b10000000000000000100100 8
b0 7
b100100000010000000000000000001 6
bx 5
bx 4
bx 3
b0 2
b10000000000000000100100 1
b10000000000000000100000 0
0/
bx .
b10000000000000000100100 -
bx ,
b10000000000000000100000 +
b100100000010000000000000000001 *
b1000000000000000000100 )
bx (
b10000000000000000100100 '
bx &
bx %
b1 $
bx #
b0 "
b1000 !
$end
#10
b10000000000000000101000 '
b10000000000000000101000 ;
b10000000000000000101000 F
b10000000000000000101000 -
b10000000000000000101000 1
b10000000000000000101000 8
b10 $
b10 @
b10 R
b10 Q
b1001 I
b1001000000000000001000 )
b1001000000000000001000 :
b1001000000000000001000 U
b10000000000000000101000 V
b1001 !
b1001 E
b1001 L
b100100000010010000000000000010 *
b100100000010010000000000000010 6
b100100000010010000000000000010 =
b100100000010010000000000000010 D
b100100000010010000000000000010 T
b100100000010010000000000000010 X
b100000000000000001001 >
b10000000000000000100100 +
b10000000000000000100100 0
b10000000000000000100100 <
b10000000000000000100100 G
b10000000000000000100100 S
1/
#20
0/
#30
b10000000000000000101100 '
b10000000000000000101100 ;
b10000000000000000101100 F
b10000000000000000101100 -
b10000000000000000101100 1
b10000000000000000101100 8
b1 $
b1 @
b1 R
b1 Q
b10 I
b10000000000000000100 )
b10000000000000000100 :
b10000000000000000100 U
b10000000000000000101100 V
b10 !
b10 E
b10 L
b100100000000100000000000000001 *
b100100000000100000000000000001 6
b100100000000100000000000000001 =
b100100000000100000000000000001 D
b100100000000100000000000000001 T
b100100000000100000000000000001 X
b100000000000000001010 >
b10000000000000000101000 +
b10000000000000000101000 0
b10000000000000000101000 <
b10000000000000000101000 G
b10000000000000000101000 S
1/
#40
0/
#50
b10000000000000000110000 '
b10000000000000000110000 ;
b10000000000000000110000 F
b10000000000000000110000 -
b10000000000000000110000 1
b10000000000000000110000 8
b10000000100000 $
b10000000100000 @
b10000000100000 R
b10 2
1K
1C
b10000000100000 Q
b1000 I
b1001 H
b10000010100 "
b10000010100 7
b101000001000000010000000 )
b101000001000000010000000 :
b101000001000000010000000 U
b10000000000000000110000 V
b100 !
b100 E
b100 L
b1001010000010000000100000 *
b1001010000010000000100000 6
b1001010000010000000100000 =
b1001010000010000000100000 D
b1001010000010000000100000 T
b1001010000010000000100000 X
b100000000000000001011 >
b10000000000000000101100 +
b10000000000000000101100 0
b10000000000000000101100 <
b10000000000000000101100 G
b10000000000000000101100 S
1/
#60
0/
#70
b10000000000000000110100 '
b10000000000000000110100 ;
b10000000000000000110100 F
b10000000000000000110100 -
b10000000000000000110100 1
b10000000000000000110100 8
b1100 $
b1100 @
b1100 R
b0 2
0K
0C
b1100 Q
b0 I
b0 H
b110000 )
b110000 :
b110000 U
b10000000000000000110100 V
b0 "
b0 7
b0 !
b0 E
b0 L
b1100 *
b1100 6
b1100 =
b1100 D
b1100 T
b1100 X
b100000000000000001100 >
b10000000000000000110000 +
b10000000000000000110000 0
b10000000000000000110000 <
b10000000000000000110000 G
b10000000000000000110000 S
1/
#80
0/
#90
b10000000000000000111000 '
b10000000000000000111000 ;
b10000000000000000111000 F
b10000000000000000111000 -
b10000000000000000111000 1
b10000000000000000111000 8
b1010 $
b1010 @
b1010 R
b1010 Q
b10 I
b10000000000000101000 )
b10000000000000101000 :
b10000000000000101000 U
b10000000000000000111000 V
b10 !
b10 E
b10 L
b100100000000100000000000001010 *
b100100000000100000000000001010 6
b100100000000100000000000001010 =
b100100000000100000000000001010 D
b100100000000100000000000001010 T
b100100000000100000000000001010 X
b100000000000000001101 >
b10000000000000000110100 +
b10000000000000000110100 0
b10000000000000000110100 <
b10000000000000000110100 G
b10000000000000000110100 S
1/
#100
0/
#110
b10000000000000000111100 '
b10000000000000000111100 ;
b10000000000000000111100 F
b10000000000000000111100 -
b10000000000000000111100 1
b10000000000000000111100 8
b1100 $
b1100 @
b1100 R
b1100 Q
b0 I
b110000 )
b110000 :
b110000 U
b10000000000000000111100 V
b0 !
b0 E
b0 L
b1100 *
b1100 6
b1100 =
b1100 D
b1100 T
b1100 X
b100000000000000001110 >
b10000000000000000111000 +
b10000000000000000111000 0
b10000000000000000111000 <
b10000000000000000111000 G
b10000000000000000111000 S
1/
#120
0/
#130
b10000000000000001000000 '
b10000000000000001000000 ;
b10000000000000001000000 F
b10000000000000001000000 -
b10000000000000001000000 1
b10000000000000001000000 8
b0 $
b0 @
b0 R
b0 Q
b0 )
b0 :
b0 U
b10000000000000001000000 V
b0 *
b0 6
b0 =
b0 D
b0 T
b0 X
b100000000000000001111 >
b10000000000000000111100 +
b10000000000000000111100 0
b10000000000000000111100 <
b10000000000000000111100 G
b10000000000000000111100 S
1/
#140
0/
